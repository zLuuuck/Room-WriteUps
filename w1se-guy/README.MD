# üß† TryHackMe ‚Äì W1seGuy (Cryptography CTF)

## Descri√ß√£o da Sala  
W1seGuy √© um desafio de criptografia que explora uma cifragem XOR b√°sica com chave repetida de 5 caracteres.  
O objetivo √© recuperar duas flags:

- **Flag 1**: cifrada via XOR e apresentada em hexadecimal.  
- **Flag 2**: revelada ap√≥s o envio da chave correta ao servidor.

---

## ‚öôÔ∏è Funcionamento do Desafio

O servidor:

- Gera uma **chave aleat√≥ria de 5 caracteres** (letras e d√≠gitos).
- Aplica **XOR entre a flag e a chave repetida**.
- Converte o resultado para **hexadecimal** e o envia ao cliente.
- Espera que o cliente envie a chave correta para revelar a segunda flag.

---

## üß© L√≥gica de Resolu√ß√£o

### 1. Ataque de Known-Plaintext
Sabendo que flags no TryHackMe seguem o padr√£o `THM{...}`:

- Aplicamos XOR entre os 4 primeiros bytes do texto cifrado e `THM{` para descobrir os 4 primeiros caracteres da chave.

### 2. For√ßa Bruta no Caractere Restante

- Como a chave tem 5 caracteres, realizamos brute-force nos **62 poss√≠veis caracteres alfanum√©ricos (A-Za-z0-9)** para o √∫ltimo byte da chave.

### 3. Descriptografar e Validar

- Com a chave completa, aplicamos XOR novamente sobre o texto inteiro.
- Se o resultado for leg√≠vel e terminar com `}`, a flag foi recuperada com sucesso.

---

## üõ†Ô∏è Ferramentas e Estrat√©gias

- Python 3  
- XOR com chave repetida  
- Ataque de texto conhecido (known-plaintext)  
- Brute-force parcial  
- Valida√ß√£o de padr√£o (`THM{}`)
- VSCode para cria√ß√£o do script
- NC(Netcat) para conex√£o do servidor

---

## üí° Script de Automa√ß√£o (Python)

```python
import string
from itertools import product

def xor_descriptografar(texto_cifrado_hex, texto_claro_conhecido="THM{", tamanho_chave=5):
    bytes_texto_cifrado = bytes.fromhex(texto_cifrado_hex)
    bytes_texto_claro_conhecido = texto_claro_conhecido.encode()

    # Descobrir os primeiros bytes da chave usando a parte conhecida do texto claro
    bytes_chave = [bytes_texto_cifrado[i] ^ bytes_texto_claro_conhecido[i] for i in range(len(bytes_texto_claro_conhecido))]

    # Espa√ßo reservado para os bytes restantes da chave
    for _ in range(len(bytes_texto_claro_conhecido), tamanho_chave):
        bytes_chave.append(0)

    conjunto_caracteres = string.ascii_letters + string.digits

    # For√ßa bruta para os bytes restantes da chave
    for caracteres_combinados in product(conjunto_caracteres, repeat=tamanho_chave - len(bytes_texto_claro_conhecido)):
        for i, char_atual in enumerate(caracteres_combinados):
            bytes_chave[len(bytes_texto_claro_conhecido) + i] = ord(char_atual)

        chave = bytes(bytes_chave)
        descriptografado = bytes([bytes_texto_cifrado[i] ^ chave[i % tamanho_chave] for i in range(len(bytes_texto_cifrado))])

        try:
            decodificado = descriptografado.decode()
            if decodificado.startswith("THM{") and decodificado.endswith("}"):
                return decodificado, chave.decode()
        except UnicodeDecodeError:
            continue

    return None, None

if __name__ == "__main__":
    texto_cifrado_hex = input("Cole o XOR codificado (hex): ").strip()
    flag_encontrada, chave_descoberta = xor_descriptografar(texto_cifrado_hex)

    if flag_encontrada:
        print("\n[+] Flag encontrada:", flag_encontrada)
        print("[+] Chave descoberta:", chave_descoberta)
    else:
        print("[-] N√£o foi poss√≠vel descriptografar a flag.")
```
---
## üß† Li√ß√µes Aprendidas

### ‚úÖ Conceituais

- Criptografia fraca com XOR e chave curta √© altamente vulner√°vel, principalmente se a estrutura do plaintext for previs√≠vel.
- Conhecimento pr√©vio de padr√µes como `THM{...}` viabiliza ataques de known-plaintext extremamente eficazes.
- A repeti√ß√£o da chave em cifragem sim√©trica (key-reuse) permite ataques segmentados que reduzem significativamente o espa√ßo de busca.

### üß™ T√©cnicas

- Utilizar XOR reverso permite identificar a chave byte a byte com base em fragmentos conhecidos.
- Ataques de for√ßa bruta s√£o vi√°veis quando:
  - O comprimento da chave √© pequeno.
  - O conjunto de caracteres poss√≠vel √© limitado (ex: letras e n√∫meros).
- Valida√ß√£o de prefixo e sufixo (`startswith`, `endswith`) √© √∫til para verificar rapidamente se o resultado da decodifica√ß√£o √© v√°lido.

### üö© Boas Pr√°ticas

- Sistemas reais nunca devem usar XOR puro com chave fixa ou pequena.
- Sempre utilize criptografia autenticada (ex: AES-GCM, ChaCha20-Poly1305) com gera√ß√£o segura de chaves.
- Mesmo desafios simples como este ajudam a compreender os princ√≠pios de quebra de criptografia na pr√°tica.

---

## üñºÔ∏è Execu√ß√£o

Abaixo est√° uma captura de tela da execu√ß√£o do script de descriptografia:

![Execu√ß√£o do Script](imagem.png)

# ðŸ§  TryHackMe â€“ W1seGuy (Cryptography CTF)

## DescriÃ§Ã£o da Sala  
W1seGuy Ã© um desafio de criptografia que explora uma cifragem XOR bÃ¡sica com chave repetida de 5 caracteres.  
O objetivo Ã© recuperar duas flags:

- **Flag 1**: cifrada via XOR e apresentada em hexadecimal.  
- **Flag 2**: revelada apÃ³s o envio da chave correta ao servidor.

---

## âš™ï¸ Funcionamento do Desafio

O servidor:

- Gera uma **chave aleatÃ³ria de 5 caracteres** (letras e dÃ­gitos).
- Aplica **XOR entre a flag e a chave repetida**.
- Converte o resultado para **hexadecimal** e o envia ao cliente.
- Espera que o cliente envie a chave correta para revelar a segunda flag.

---

## ðŸ§© LÃ³gica de ResoluÃ§Ã£o

### 1. Ataque de Known-Plaintext
Sabendo que flags no TryHackMe seguem o padrÃ£o `THM{...}`:

- Aplicamos XOR entre os 4 primeiros bytes do texto cifrado e `THM{` para descobrir os 4 primeiros caracteres da chave.

### 2. ForÃ§a Bruta no Caractere Restante

- Como a chave tem 5 caracteres, realizamos brute-force nos **62 possÃ­veis caracteres alfanumÃ©ricos (A-Za-z0-9)** para o Ãºltimo byte da chave.

### 3. Descriptografar e Validar

- Com a chave completa, aplicamos XOR novamente sobre o texto inteiro.
- Se o resultado for legÃ­vel e terminar com `}`, a flag foi recuperada com sucesso.

---

## ðŸ› ï¸ Ferramentas e EstratÃ©gias

- Python 3  
- XOR com chave repetida  
- Ataque de texto conhecido (known-plaintext)  
- Brute-force parcial  
- ValidaÃ§Ã£o de padrÃ£o (`THM{}`)
- VSCode para criaÃ§Ã£o do script
- NC(Netcat) para conexÃ£o do servidor

---

## ðŸ’¡ Script de AutomaÃ§Ã£o (Python)

```python
import string
from itertools import product

def xor_descriptografar(texto_cifrado_hex, texto_claro_conhecido="THM{", tamanho_chave=5):
    bytes_texto_cifrado = bytes.fromhex(texto_cifrado_hex)
    bytes_texto_claro_conhecido = texto_claro_conhecido.encode()

    # Descobrir os primeiros bytes da chave usando a parte conhecida do texto claro
    bytes_chave = [bytes_texto_cifrado[i] ^ bytes_texto_claro_conhecido[i] for i in range(len(bytes_texto_claro_conhecido))]

    # EspaÃ§o reservado para os bytes restantes da chave
    for _ in range(len(bytes_texto_claro_conhecido), tamanho_chave):
        bytes_chave.append(0)

    conjunto_caracteres = string.ascii_letters + string.digits

    # ForÃ§a bruta para os bytes restantes da chave
    for caracteres_combinados in product(conjunto_caracteres, repeat=tamanho_chave - len(bytes_texto_claro_conhecido)):
        for i, char_atual in enumerate(caracteres_combinados):
            bytes_chave[len(bytes_texto_claro_conhecido) + i] = ord(char_atual)

        chave = bytes(bytes_chave)
        descriptografado = bytes([bytes_texto_cifrado[i] ^ chave[i % tamanho_chave] for i in range(len(bytes_texto_cifrado))])

        try:
            decodificado = descriptografado.decode()
            if decodificado.startswith("THM{") and decodificado.endswith("}"):
                return decodificado, chave.decode()
        except UnicodeDecodeError:
            continue

    return None, None

if __name__ == "__main__":
    texto_cifrado_hex = input("Cole o XOR codificado (hex): ").strip()
    flag_encontrada, chave_descoberta = xor_descriptografar(texto_cifrado_hex)

    if flag_encontrada:
        print("\n[+] Flag encontrada:", flag_encontrada)
        print("[+] Chave descoberta:", chave_descoberta)
    else:
        print("[-] NÃ£o foi possÃ­vel descriptografar a flag.")
```
---
## ðŸ§  LiÃ§Ãµes Aprendidas

### âœ… Conceituais

- Criptografia fraca com XOR e chave curta Ã© altamente vulnerÃ¡vel, principalmente se a estrutura do plaintext for previsÃ­vel.
- Conhecimento prÃ©vio de padrÃµes como `THM{...}` viabiliza ataques de known-plaintext extremamente eficazes.
- A repetiÃ§Ã£o da chave em cifragem simÃ©trica (key-reuse) permite ataques segmentados que reduzem significativamente o espaÃ§o de busca.

### ðŸ§ª TÃ©cnicas

- Utilizar XOR reverso permite identificar a chave byte a byte com base em fragmentos conhecidos.
- Ataques de forÃ§a bruta sÃ£o viÃ¡veis quando:
  - O comprimento da chave Ã© pequeno.
  - O conjunto de caracteres possÃ­vel Ã© limitado (ex: letras e nÃºmeros).
- ValidaÃ§Ã£o de prefixo e sufixo (`startswith`, `endswith`) Ã© Ãºtil para verificar rapidamente se o resultado da decodificaÃ§Ã£o Ã© vÃ¡lido.

### ðŸš© Boas PrÃ¡ticas

- Sistemas reais nunca devem usar XOR puro com chave fixa ou pequena.
- Sempre utilize criptografia autenticada (ex: AES-GCM, ChaCha20-Poly1305) com geraÃ§Ã£o segura de chaves.
- Mesmo desafios simples como este ajudam a compreender os princÃ­pios de quebra de criptografia na prÃ¡tica.

---

## ðŸ–¼ï¸ ExecuÃ§Ã£o

Abaixo estÃ¡ uma captura de tela da execuÃ§Ã£o do script de descriptografia:

![ExecuÃ§Ã£o do Script](caminho/para/sua/imagem.png)

> ðŸ“Œ Substitua `caminho/para/sua/imagem.png` pelo caminho real da sua imagem.  
> Exemplo: `images/execution.png` ou o link direto de um GitHub CDN.
